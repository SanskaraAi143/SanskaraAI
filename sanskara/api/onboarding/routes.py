import logging
from fastapi import APIRouter, HTTPException
from api.onboarding.models import OnboardingSubmission, SecondPartnerSubmission
from sanskara.helpers import execute_supabase_sql
import sanskara.db_queries as db_queries
from api.onboarding.services import (
    _update_existing_partner_details,
    _handle_first_partner_submission,
    _handle_second_partner_submission
)

logger = logging.getLogger(__name__)
onboarding_router = APIRouter()

@onboarding_router.post("/submit")
async def submit_onboarding_data(submission: OnboardingSubmission | SecondPartnerSubmission):
    logger.info(f"Received onboarding submission from {submission.current_partner_email}")

    current_partner_email = submission.current_partner_email
    other_partner_email = None
    if type(submission) is OnboardingSubmission:
        other_partner_email = submission.other_partner_email

    current_partner_details_json = submission.current_partner_details.model_dump_json()

    # Extract role from the submission details
    current_partner_role = submission.current_partner_details.role

    user_query_result = await execute_supabase_sql(db_queries.get_user_and_wedding_info_by_email_query(current_partner_email))
    existing_user_data = user_query_result.get("data")

    user_id = None
    existing_wedding_id = None
    existing_role = None

    if existing_user_data:
        user_id = existing_user_data[0].get("user_id")
        existing_wedding_id = existing_user_data[0].get("wedding_id") # This will now come from wedding_members join
        existing_role = existing_user_data[0].get("role")

    if not user_id:
        logger.error(f"User with email {current_partner_email} not found in the users table.")
        raise HTTPException(status_code=404, detail=f"User with email {current_partner_email} not found. Please ensure you have signed up.")

    if existing_wedding_id:
        # User exists and is already linked to a wedding via wedding_members
        return await _update_existing_partner_details(current_partner_email, current_partner_details_json, existing_wedding_id, user_id, current_partner_role)
    elif other_partner_email:
        # First partner submission
        return await _handle_first_partner_submission(current_partner_email, current_partner_details_json, other_partner_email)
    else:
        # Second partner submission
        return await _handle_second_partner_submission(current_partner_email, current_partner_details_json)

@onboarding_router.get("/partner-details")
async def get_partner_details(email: str):
    logger.info(f"Received request for partner details for email: {email}")

    # Search for a wedding where this email is the expected other partner
    find_wedding_sql = db_queries.get_wedding_by_expected_partner_email_query(email)
    wedding_query = await execute_supabase_sql(find_wedding_sql)
    wedding_data = wedding_query.get("data")

    if not wedding_data:
        raise HTTPException(status_code=404, detail="No wedding found associated with this email as an expected partner.")

    wedding_id = wedding_data[0]["wedding_id"]
    wedding_details = wedding_data[0]["details"]
    partner_data = wedding_details.get("partner_data", {})
    other_partner_email_expected = wedding_details.get("other_partner_email_expected")

    first_partner_email = None
    # Determine who the first partner was (the one who provided other_partner_email_expected)
    for p_email, p_details in partner_data.items():
        if p_email != other_partner_email_expected:
            first_partner_email = p_email
            break

    first_partner_info = {}
    if first_partner_email and first_partner_email in partner_data:
        first_partner_info = partner_data[first_partner_email]

    # Placeholder for proposed plan/responsibilities
    proposed_plan = {
        "message": "Proposed plan and responsibilities will be generated by the SetupAgent after both partners onboard.",
        "example_responsibility": "Budget management",
        "example_task": "Venue selection"
    }

    return {
        "wedding_id": str(wedding_id),
        "first_partner_name": first_partner_info.get("name", "N/A"),
        "first_partner_details": first_partner_info,
        "wedding_details": wedding_details,
        "proposed_plan_responsibilities": proposed_plan
    }